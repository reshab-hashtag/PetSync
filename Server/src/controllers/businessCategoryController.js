// Server/src/controllers/businessCategoryController.js
const BusinessCategory = require('../models/BusinessCategory');
const Business = require('../models/Business');
const { ROLES } = require('../config/constants');
const { default: mongoose } = require('mongoose');

const businessCategoryController = {
  // Get all categories (accessible to all authenticated users)
  async getAllCategories(req, res, next) {
    try {
      const { active, search, page = 1, limit = 50 } = req.query;
      
      const filter = {};
      
      // Filter by active status
      if (active !== undefined) {
        filter.isActive = active === 'true';
      }
      
      // Search filter
      if (search) {
        filter.$or = [
          { name: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } }
        ];
      }
      
      const skip = (parseInt(page) - 1) * parseInt(limit);
      
      const [categories, total] = await Promise.all([
        BusinessCategory.find(filter)
          .sort({ displayOrder: 1, name: 1 })
          .skip(skip)
          .limit(parseInt(limit))
          .populate('createdBy', 'profile.firstName profile.lastName'),
        BusinessCategory.countDocuments(filter)
      ]);
      
      res.json({
        success: true,
        data: {
          categories,
          pagination: {
            current: parseInt(page),
            total: Math.ceil(total / parseInt(limit)),
            count: categories.length,
            totalRecords: total
          }
        }
      });
    } catch (error) {
      next(error);
    }
  },

  // Get active categories for dropdowns
  async getActiveCategories(req, res, next) {
    try {
      const categories = await BusinessCategory.find({ isActive: true })
        .sort({ displayOrder: 1, name: 1 })
        .select('name slug description icon color');
      
      res.json({
        success: true,
        data: categories
      });
    } catch (error) {
      next(error);
    }
  },

  // Get single category
  async getCategory(req, res, next) {
    try {
      const { id } = req.params;
      
      const category = await BusinessCategory.findById(id)
        .populate('createdBy', 'profile.firstName profile.lastName profile.email');
      
      if (!category) {
        return res.status(404).json({
          success: false,
          message: 'Business category not found'
        });
      }
      
      // Get usage stats
      const businessCount = await Business.countDocuments({ 
        'profile.category': category.slug 
      });
      
      res.json({
        success: true,
        data: {
          ...category.toObject(),
          stats: {
            businessCount
          }
        }
      });
    } catch (error) {
      next(error);
    }
  },

  // Create new category (Super Admin only)
async createCategory(req, res, next) {
  try {
    const {
      name,
      description,
      icon,
      color,
      displayOrder,
      metadata
    } = req.body;

    // Validate required fields
    if (!name || !name.trim()) {
      return res.status(400).json({
        success: false,
        message: 'Category name is required'
      });
    }

    // Check if category with same name exists (case-insensitive)
    const existingCategory = await BusinessCategory.findOne({
      name: { $regex: new RegExp(`^${name.trim()}$`, 'i') }
    });

    if (existingCategory) {
      return res.status(400).json({
        success: false,
        message: 'A category with this name already exists'
      });
    }

    // Create the category (slug will be auto-generated by pre-save middleware)
    const category = new BusinessCategory({
      name: name.trim(),
      description: description?.trim() || '',
      icon: icon || 'BuildingOfficeIcon',
      color: color || '#3B82F6',
      displayOrder: displayOrder || 0,
      metadata: {
        tags: metadata?.tags || [],
        allowCustomServices: metadata?.allowCustomServices !== undefined ? metadata.allowCustomServices : true,
        requiresSpecialLicense: metadata?.requiresSpecialLicense !== undefined ? metadata.requiresSpecialLicense : false
      },
      createdBy: req.user.userId
    });

    // Save the category
    await category.save();

    // Populate the createdBy field for response
    await category.populate('createdBy', 'profile.firstName profile.lastName');

    res.status(201).json({
      success: true,
      message: 'Business category created successfully',
      data: category
    });
  } catch (error) {
    // Handle unique constraint errors
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      let message = 'A category with this information already exists';
      
      if (field === 'name') {
        message = 'A category with this name already exists';
      } else if (field === 'slug') {
        message = 'A category with this name already exists (slug conflict)';
      }
      
      return res.status(400).json({
        success: false,
        message: message
      });
    }
    
    // Handle validation errors
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: messages
      });
    }
    
    next(error);
  }
},

  // Update category (Super Admin only)
  async updateCategory(req, res, next) {
    try {
      const { id } = req.params;
      const {
        name,
        description,
        icon,
        color,
        isActive,
        displayOrder,
        metadata
      } = req.body;
      
      const category = await BusinessCategory.findById(id);
      
      if (!category) {
        return res.status(404).json({
          success: false,
          message: 'Business category not found'
        });
      }
      
      // Check if another category with same name exists
      if (name && name !== category.name) {
        const existingCategory = await BusinessCategory.findOne({ 
          name: { $regex: new RegExp(`^${name}$`, 'i') },
          _id: { $ne: id }
        });
        
        if (existingCategory) {
          return res.status(400).json({
            success: false,
            message: 'A category with this name already exists'
          });
        }
      }
      
      // Update fields
      if (name !== undefined) category.name = name;
      if (description !== undefined) category.description = description;
      if (icon !== undefined) category.icon = icon;
      if (color !== undefined) category.color = color;
      if (isActive !== undefined) category.isActive = isActive;
      if (displayOrder !== undefined) category.displayOrder = displayOrder;
      if (metadata !== undefined) category.metadata = { ...category.metadata, ...metadata };
      
      category.updatedAt = new Date();
      
      await category.save();
      await category.populate('createdBy', 'profile.firstName profile.lastName');
      
      res.json({
        success: true,
        message: 'Business category updated successfully',
        data: category
      });
    } catch (error) {
      if (error.code === 11000) {
        const field = Object.keys(error.keyPattern)[0];
        return res.status(400).json({
          success: false,
          message: `A category with this ${field} already exists`
        });
      }
      next(error);
    }
  },

  // Delete category (Super Admin only)
  async deleteCategory(req, res, next) {
  console.log('Delete category request received');
  try {
    const { id } = req.params;
    
    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid category ID format'
      });
    }
    
    const category = await BusinessCategory.findById(id);
    
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Business category not found'
      });
    }
    
    // Check if category is being used by any businesses
    const businessCount = await Business.countDocuments({ 
      'profile.category': category._id 
    });
    
    if (businessCount > 0) {
      return res.status(400).json({
        success: false,
        message: `Cannot delete category. It is currently used by ${businessCount} business${businessCount > 1 ? 'es' : ''}`
      });
    }
    
    await BusinessCategory.findByIdAndDelete(id);
    
    res.json({
      success: true,
      message: 'Business category deleted successfully'
    });
  } catch (error) {
    console.error('Delete category error:', error);
    next(error);
  }
},

  // Bulk update display order (Super Admin only)
  async updateDisplayOrder(req, res, next) {
    try {
      const { categories } = req.body; // Array of { id, displayOrder }
      
      if (!Array.isArray(categories)) {
        return res.status(400).json({
          success: false,
          message: 'Categories must be an array'
        });
      }
      
      const bulkOps = categories.map(({ id, displayOrder }) => ({
        updateOne: {
          filter: { _id: id },
          update: { $set: { displayOrder, updatedAt: new Date() } }
        }
      }));
      
      await BusinessCategory.bulkWrite(bulkOps);
      
      res.json({
        success: true,
        message: 'Display order updated successfully'
      });
    } catch (error) {
      next(error);
    }
  },

  // Get category statistics (Super Admin only)
  async getCategoryStats(req, res, next) {
    try {
      const stats = await BusinessCategory.aggregate([
        {
          $lookup: {
            from: 'businesses',
            localField: 'slug',
            foreignField: 'profile.category',
            as: 'businesses'
          }
        },
        {
          $project: {
            name: 1,
            slug: 1,
            isActive: 1,
            businessCount: { $size: '$businesses' },
            createdAt: 1
          }
        },
        {
          $sort: { businessCount: -1 }
        }
      ]);
      
      const summary = {
        totalCategories: await BusinessCategory.countDocuments(),
        activeCategories: await BusinessCategory.countDocuments({ isActive: true }),
        totalBusinesses: await Business.countDocuments(),
        categoriesWithBusinesses: stats.filter(cat => cat.businessCount > 0).length
      };
      
      res.json({
        success: true,
        data: {
          summary,
          categoryStats: stats
        }
      });
    } catch (error) {
      next(error);
    }
  }
};

module.exports = businessCategoryController;